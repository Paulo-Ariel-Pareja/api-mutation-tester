import { Test, TestingModule } from '@nestjs/testing';
import { VulnerabilityDetectorService } from './vulnerability-detector.service';
import { Mutation, TestResult, MutationType, HttpMethod } from '@api-mutation-tester/shared';

describe('VulnerabilityDetectorService', () => {
  let service: VulnerabilityDetectorService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [VulnerabilityDetectorService],
    }).compile();

    service = module.get<VulnerabilityDetectorService>(VulnerabilityDetectorService);
  });

  describe('detectVulnerability', () => {
    const createMutation = (type: MutationType, payload?: any): Mutation => ({
      id: 'test-mutation',
      type,
      description: 'Test mutation',
      modifiedRequest: {
        url: 'https://api.example.com/test',
        method: HttpMethod.POST,
        headers: {},
        payload,
        timeout: 5000,
      },
      mutationStrategy: 'Test strategy',
    });

    const createTestResult = (statusCode: number, responseBody?: any, error?: string): TestResult => ({
      id: 'test-result',
      isHappyPath: false,
      statusCode,
      responseTime: 100,
      responseBody,
      error,
      vulnerabilityDetected: false,
      integrityIssue: false,
      timestamp: new Date(),
    });

    it('should detect malicious input acceptance', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS, {
        script: '<script>alert(1)</script>'
      });
      const result = createTestResult(200, { success: true });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should detect script injection acceptance', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS, {
        input: 'javascript:alert(1)'
      });
      const result = createTestResult(201, { created: true });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should not flag malicious input that is properly rejected', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS, {
        script: '<script>alert(1)</script>'
      });
      const result = createTestResult(400, { error: 'Invalid input' });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeFalsy();
    });

    it('should detect information disclosure in error responses', () => {
      const mutation = createMutation(MutationType.STRING_EMPTY);
      const result = createTestResult(500, {
        error: 'Database connection failed: mysql://user:password@localhost:3306/db'
      });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should detect stack trace disclosure', () => {
      const mutation = createMutation(MutationType.TYPE_NULL);
      const result = createTestResult(500, {
        error: 'NullPointerException at com.example.service.UserService.getUser(UserService.java:42)'
      });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should detect file system path disclosure', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS);
      const result = createTestResult(500, {
        error: 'File not found: /etc/passwd'
      });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should detect validation bypass', () => {
      const mutation = createMutation(MutationType.TYPE_NULL);
      const result = createTestResult(200, { success: true });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should detect long string acceptance', () => {
      const mutation = createMutation(MutationType.STRING_LONG);
      const result = createTestResult(200, { success: true });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should detect large number acceptance', () => {
      const mutation = createMutation(MutationType.NUMERIC_LARGE, {
        value: 999999999999999
      });
      const result = createTestResult(200, { success: true });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeTruthy();
    });

    it('should not flag successful responses for safe mutations', () => {
      const mutation = createMutation(MutationType.TYPE_BOOLEAN);
      const result = createTestResult(200, { success: true });

      const isVulnerable = service.detectVulnerability(mutation, result);

      expect(isVulnerable).toBeFalsy();
    });

    it('should handle errors gracefully', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS);
      const result = createTestResult(400); // Use error status to avoid malicious input detection
      
      // Create a result with a circular reference to cause JSON.stringify to fail
      const circularResult = { ...result };
      circularResult.responseBody = { self: circularResult };

      const isVulnerable = service.detectVulnerability(mutation, circularResult);

      expect(isVulnerable).toBeFalsy();
    });
  });

  describe('detectIntegrityIssue', () => {
    const createMutation = (type: MutationType): Mutation => ({
      id: 'test-mutation',
      type,
      description: 'Test mutation',
      modifiedRequest: {
        url: 'https://api.example.com/test',
        method: HttpMethod.POST,
        headers: {},
        timeout: 5000,
      },
      mutationStrategy: 'Test strategy',
    });

    const createTestResult = (statusCode: number, responseTime: number = 100, error?: string): TestResult => ({
      id: 'test-result',
      isHappyPath: false,
      statusCode,
      responseTime,
      responseBody: {},
      error,
      vulnerabilityDetected: false,
      integrityIssue: false,
      timestamp: new Date(),
    });

    const createHappyPathResult = (): TestResult => ({
      id: 'happy-path',
      isHappyPath: true,
      statusCode: 200,
      responseTime: 100,
      responseBody: { success: true },
      vulnerabilityDetected: false,
      integrityIssue: false,
      timestamp: new Date(),
    });

    it('should detect service unavailability from connection errors', () => {
      const mutation = createMutation(MutationType.STRING_LONG);
      const result = createTestResult(0, 0, 'ECONNREFUSED');

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect service unavailability from timeout errors', () => {
      const mutation = createMutation(MutationType.STRING_LONG);
      const result = createTestResult(0, 0, 'ETIMEDOUT');

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect service unavailability from 5xx status codes', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS);
      const result = createTestResult(500);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect service unavailability from 502 Bad Gateway', () => {
      const mutation = createMutation(MutationType.TYPE_NULL);
      const result = createTestResult(502);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect service unavailability from 503 Service Unavailable', () => {
      const mutation = createMutation(MutationType.NUMERIC_LARGE);
      const result = createTestResult(503);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect service unavailability from extremely long response times', () => {
      const mutation = createMutation(MutationType.STRING_LONG);
      const result = createTestResult(200, 35000); // 35 seconds

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect unexpected successful responses for empty strings', () => {
      const mutation = createMutation(MutationType.STRING_EMPTY);
      const result = createTestResult(200);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect unexpected successful responses for missing fields', () => {
      const mutation = createMutation(MutationType.MISSING_FIELD);
      const result = createTestResult(201);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect unexpected successful responses for null values', () => {
      const mutation = createMutation(MutationType.TYPE_NULL);
      const result = createTestResult(200);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect response time anomalies', () => {
      const mutation = createMutation(MutationType.STRING_LONG);
      const result = createTestResult(200, 6000); // 6 seconds
      const happyPathResult = createHappyPathResult(); // 100ms

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result, happyPathResult);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect response size anomalies', () => {
      const mutation = createMutation(MutationType.EXTRA_FIELD);
      const largeResponse = { data: 'x'.repeat(50000) }; // Large response
      const result: TestResult = {
        ...createTestResult(200),
        responseBody: largeResponse,
      };
      const happyPathResult = createHappyPathResult(); // Small response

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result, happyPathResult);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should detect server errors when happy path was successful', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS);
      const result = createTestResult(500);
      const happyPathResult = createHappyPathResult();

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result, happyPathResult);

      expect(hasIntegrityIssue).toBeTruthy();
    });

    it('should not flag normal error responses', () => {
      const mutation = createMutation(MutationType.STRING_EMPTY);
      const result = createTestResult(400);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeFalsy();
    });

    it('should not flag acceptable successful responses', () => {
      const mutation = createMutation(MutationType.TYPE_BOOLEAN);
      const result = createTestResult(200);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeFalsy();
    });

    it('should handle missing happy path result gracefully', () => {
      const mutation = createMutation(MutationType.STRING_LONG);
      const result = createTestResult(200, 6000);

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeFalsy();
    });

    it('should handle errors gracefully', () => {
      const mutation = createMutation(MutationType.STRING_MALICIOUS);
      const result = createTestResult(200);
      
      // Simulate an error in detection logic
      jest.spyOn(JSON, 'stringify').mockImplementationOnce(() => {
        throw new Error('JSON error');
      });

      const hasIntegrityIssue = service.detectIntegrityIssue(mutation, result);

      expect(hasIntegrityIssue).toBeFalsy();
    });
  });

  describe('edge cases and error handling', () => {
    it('should handle null/undefined inputs gracefully', () => {
      const mutation = {
        id: 'test',
        type: MutationType.STRING_EMPTY,
        description: 'test',
        modifiedRequest: {
          url: 'https://api.example.com',
          method: HttpMethod.GET,
          headers: {},
          timeout: 5000,
        },
        mutationStrategy: 'test',
      };

      const result = {
        id: 'test',
        isHappyPath: false,
        statusCode: 200,
        responseTime: 100,
        responseBody: null,
        vulnerabilityDetected: false,
        integrityIssue: false,
        timestamp: new Date(),
      };

      expect(() => service.detectVulnerability(mutation, result)).not.toThrow();
      expect(() => service.detectIntegrityIssue(mutation, result)).not.toThrow();
    });

    it('should handle circular references in response body', () => {
      const mutation = {
        id: 'test',
        type: MutationType.STRING_MALICIOUS,
        description: 'test',
        modifiedRequest: {
          url: 'https://api.example.com',
          method: HttpMethod.POST,
          headers: {},
          payload: { script: '<script>alert(1)</script>' },
          timeout: 5000,
        },
        mutationStrategy: 'test',
      };

      const circularObj: any = { name: 'test' };
      circularObj.self = circularObj;

      const result = {
        id: 'test',
        isHappyPath: false,
        statusCode: 200,
        responseTime: 100,
        responseBody: circularObj,
        vulnerabilityDetected: false,
        integrityIssue: false,
        timestamp: new Date(),
      };

      expect(() => service.detectVulnerability(mutation, result)).not.toThrow();
    });
  });
});