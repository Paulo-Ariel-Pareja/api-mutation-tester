import { Injectable, Logger } from '@nestjs/common';
import { Mutation, TestResult, MutationType } from '@api-mutation-tester/shared';

@Injectable()
export class VulnerabilityDetectorService {
  private readonly logger = new Logger(VulnerabilityDetectorService.name);

  /**
   * Detects vulnerabilities based on mutation type and test result
   */
  detectVulnerability(mutation: Mutation, result: TestResult): boolean {
    try {
      // Check for successful responses to malicious inputs
      if (this.isMaliciousInputAccepted(mutation, result)) {
        this.logger.warn(`Vulnerability detected: Malicious input accepted for mutation ${mutation.id}`);
        return true;
      }

      // Check for information disclosure in error responses
      if (this.hasInformationDisclosure(result)) {
        this.logger.warn(`Vulnerability detected: Information disclosure in error response for mutation ${mutation.id}`);
        return true;
      }

      // Check for validation bypass
      if (this.isValidationBypassed(mutation, result)) {
        this.logger.warn(`Vulnerability detected: Validation bypass for mutation ${mutation.id}`);
        return true;
      }

      return false;
    } catch (error) {
      this.logger.error(`Error detecting vulnerability for mutation ${mutation.id}:`, error);
      return false;
    }
  }

  /**
   * Detects integrity issues based on test result and mutation context
   */
  detectIntegrityIssue(mutation: Mutation, result: TestResult, happyPathResult?: TestResult): boolean {
    try {
      // Check for service crashes and unavailability
      if (this.isServiceUnavailable(result)) {
        this.logger.warn(`Integrity issue detected: Service unavailable for mutation ${mutation.id}`);
        return true;
      }

      // Check for unexpected successful responses
      if (this.hasUnexpectedSuccessfulResponse(mutation, result)) {
        this.logger.warn(`Integrity issue detected: Unexpected successful response for mutation ${mutation.id}`);
        return true;
      }

      // Check for response pattern anomalies
      if (happyPathResult && this.hasResponsePatternAnomaly(result, happyPathResult)) {
        this.logger.warn(`Integrity issue detected: Response pattern anomaly for mutation ${mutation.id}`);
        return true;
      }

      return false;
    } catch (error) {
      this.logger.error(`Error detecting integrity issue for mutation ${mutation.id}:`, error);
      return false;
    }
  }

  /**
   * Detects if malicious input was accepted (successful response when it should fail)
   */
  private isMaliciousInputAccepted(mutation: Mutation, result: TestResult): boolean {
    const maliciousTypes = [
      MutationType.STRING_MALICIOUS,
      MutationType.SPECIAL_CHARACTERS,
      MutationType.UNICODE_CHARACTERS
    ];

    // If the mutation contains malicious content and the response is successful
    if (maliciousTypes.includes(mutation.type) && result.statusCode >= 200 && result.statusCode < 400) {
      return true;
    }

    // Check for script injection acceptance
    if (mutation.type === MutationType.STRING_MALICIOUS) {
      const maliciousPatterns = [
        '<script',
        'javascript:',
        'alert(',
        'eval(',
        'document.cookie',
        'window.location'
      ];

      const requestStr = JSON.stringify(mutation.modifiedRequest.payload || '').toLowerCase();
      const hasScript = maliciousPatterns.some(pattern => requestStr.includes(pattern));
      
      if (hasScript && result.statusCode >= 200 && result.statusCode < 400) {
        return true;
      }
    }

    return false;
  }

  /**
   * Detects information disclosure in error responses
   */
  private hasInformationDisclosure(result: TestResult): boolean {
    // Only check error responses (4xx, 5xx)
    if (result.statusCode < 400) {
      return false;
    }

    const responseStr = JSON.stringify(result.responseBody || '').toLowerCase();
    const errorStr = (result.error || '').toLowerCase();
    const combinedResponse = `${responseStr} ${errorStr}`;

    // Patterns that indicate sensitive information disclosure
    const sensitivePatterns = [
      // Database information
      'sql', 'mysql', 'postgresql', 'mongodb', 'database',
      'table', 'column', 'constraint', 'foreign key',
      
      // File system paths
      '/etc/', '/var/', '/usr/', '/home/', 'c:\\', 'd:\\',
      'program files', 'windows', 'system32',
      
      // Stack traces and internal errors
      'stack trace', 'stacktrace', 'at java.', 'at com.',
      'at org.', 'exception in thread', 'caused by:',
      'node_modules', '__dirname', 'process.env',
      
      // Configuration and credentials
      'password', 'secret', 'token', 'api_key', 'apikey',
      'connection string', 'config', 'environment',
      
      // Internal server information
      'internal server', 'debug', 'development mode',
      'localhost', '127.0.0.1', 'port 3000', 'port 8080'
    ];

    return sensitivePatterns.some(pattern => combinedResponse.includes(pattern));
  }

  /**
   * Detects validation bypass (invalid data types accepted)
   */
  private isValidationBypassed(mutation: Mutation, result: TestResult): boolean {
    const validationBypassTypes = [
      MutationType.TYPE_BOOLEAN,
      MutationType.TYPE_ARRAY,
      MutationType.TYPE_NULL,
      MutationType.TYPE_UNDEFINED,
      MutationType.INVALID_TYPE,
      MutationType.MISSING_FIELD
    ];

    // If validation should have failed but response is successful
    if (validationBypassTypes.includes(mutation.type) && result.statusCode === 200) {
      return true;
    }

    // Check for extreme values that should be rejected
    if (mutation.type === MutationType.STRING_LONG && result.statusCode === 200) {
      return true;
    }

    if (mutation.type === MutationType.NUMERIC_LARGE && result.statusCode === 200) {
      // Check if the mutation actually contains very large numbers
      const payloadStr = JSON.stringify(mutation.modifiedRequest.payload || '');
      if (payloadStr.includes('999999999999999') || payloadStr.includes('1e+') || payloadStr.includes('Infinity')) {
        return true;
      }
    }

    return false;
  }

  /**
   * Detects if the service is unavailable or crashed
   */
  private isServiceUnavailable(result: TestResult): boolean {
    // Check for connection errors
    if (result.error) {
      const errorStr = result.error.toLowerCase();
      const connectionErrors = [
        'econnrefused',
        'enotfound',
        'etimedout',
        'econnreset',
        'network error',
        'connection refused',
        'service unavailable',
        'bad gateway',
        'gateway timeout'
      ];

      if (connectionErrors.some(error => errorStr.includes(error))) {
        return true;
      }
    }

    // Check for server error status codes that indicate service issues
    const serviceErrorCodes = [500, 502, 503, 504];
    if (serviceErrorCodes.includes(result.statusCode)) {
      return true;
    }

    // Check for extremely long response times (potential service degradation)
    if (result.responseTime > 30000) { // 30 seconds
      return true;
    }

    return false;
  }

  /**
   * Detects unexpected successful responses that should have failed
   */
  private hasUnexpectedSuccessfulResponse(mutation: Mutation, result: TestResult): boolean {
    // These mutation types should typically result in errors
    const shouldFailTypes = [
      MutationType.STRING_EMPTY,
      MutationType.STRING_LONG,
      MutationType.TYPE_NULL,
      MutationType.TYPE_UNDEFINED,
      MutationType.MISSING_FIELD,
      MutationType.INVALID_TYPE,
      MutationType.NUMERIC_LARGE,
      MutationType.NUMERIC_NEGATIVE
    ];

    // If these mutations return success, it might indicate missing validation
    if (shouldFailTypes.includes(mutation.type) && result.statusCode >= 200 && result.statusCode < 300) {
      // Additional check for truly problematic cases
      if (mutation.type === MutationType.STRING_EMPTY && mutation.originalField) {
        // Empty strings in required fields should typically fail
        return true;
      }

      if (mutation.type === MutationType.MISSING_FIELD) {
        // Missing required fields should typically fail
        return true;
      }

      if (mutation.type === MutationType.TYPE_NULL || mutation.type === MutationType.TYPE_UNDEFINED) {
        // Null/undefined in required fields should typically fail
        return true;
      }
    }

    return false;
  }

  /**
   * Detects anomalies in response patterns compared to happy path
   */
  private hasResponsePatternAnomaly(result: TestResult, happyPathResult: TestResult): boolean {
    // Check for dramatic response time differences (potential DoS)
    const responseTimeRatio = result.responseTime / happyPathResult.responseTime;
    if (responseTimeRatio > 10 && result.responseTime > 5000) {
      return true;
    }

    // Check for response size anomalies
    const resultSize = JSON.stringify(result.responseBody || '').length;
    const happyPathSize = JSON.stringify(happyPathResult.responseBody || '').length;
    
    if (happyPathSize > 0) {
      const sizeRatio = resultSize / happyPathSize;
      // Extremely large responses might indicate data leakage
      if (sizeRatio > 50 && resultSize > 10000) {
        return true;
      }
    }

    // Check for status code patterns that are concerning
    // If happy path was successful but mutation causes server errors
    if (happyPathResult.statusCode >= 200 && happyPathResult.statusCode < 300 && 
        result.statusCode >= 500) {
      return true;
    }

    return false;
  }
}